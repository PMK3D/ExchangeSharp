# ExchangeSharp
C# language binding for HOOPS Exchange. 

It can be built and used on the following platforms:
 - Windows
 - Ubuntu Linux
 - macOS

## Expectations and Disclaimer
This is an unsupported implementation. It is being developed as experimental code. 

Don't read any further unless you are willing to work with the developers to identify issues that will arise.

If you are coming to this page with an expectation that you will obtain a complete and entirely tested C# wraapper, STOP! This is not the project for you.

Expect that you may need to modify delegate declarations in order to make some functionality accessible.

Expect an API that is very similar to the HOOPS Exchange native C API.

If you are going to use ExchangeSharp, you will need a basic understanding of the HOOPS Exchange C API.

## Description
This is a direct C# language binding for HOOPS Exchange implemented in the namespace `TS3D.Exchange.Direct`. 

> Functionality found in `A3DSDKDraw.h` is _not_ included.

ExchangeSharp was created using `libclang` to parse the Exchange headers. By traversing the declarations, we have reasonable certainty for complete coverage.

### What do you mean by "Direct"?
ExchangeSharp utilitizes the [P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) approach for providing a cross-platform binding for the C# language. It does this by declaring all of the data types used by the native Exchange library in a compatible C# form.

"Direct" implies that the C# syntax you will use to access Exchange will closely resemble its C counterpart. Functions are looked up in the Exchaange library and directly invoked.

ExchangeSharp is automatically generated by a libclang-based tool. As such, all source files (except Library.cs) should be considered disposable.

#### Disadvantages. 
I put this first because I don't think you'd read it if it came afer the advantages.

1. The generation algorithm isn't perfect (yet?). This means that some function signatures (see `API.cs`) are incorrect.
	1. This means you will have to make minor modifications to this file if you find an issue.
	1. Unless you want to make this modification every time you update the ExchangeSharp code base, you should provide the change so we can improve the generation algorithm.
1. Memory management within the Exchange data model must still be understood.
	1. The lifetime of C# objects in the Direct interface has no bearing on the underlying Exchange daata model.
	1. You use ExchangeSharp functions to creaate objects, and you must use functions to explicitly delete them.
1. You must understand what an `IntPtr` is and how to use it.
	1. Exchange uses a lot of opaque pointers as "handles" into the Exchange data model. This is still the case even when using ExchangeSharp.

#### Advantages 
This approach has several advantages.

1. Memory: Data is not copied. It is directly mapped using `struct` objects. (See `ExchangeSharp/Direct/Structs.cs`)
1. Speed: There is no "middle" code. When you call an Exchange function using C#, you are directly invoking the code and nothing between. (See `ExchangeSharp/Direct/API.cs`)
1. Familiar: The code you write will look familiar:
```csharp
A3DAsmModelFileData d;
API.Initialize( out d );
if( A3DStatus.A3D_SUCCESS == API.A3DAsmModelFileGet( model_file, ref d ) ) {
    // Use object here

    // Free the object-
    API.A3DAsmModelFileGet( IntPtr.Zero, ref d );
}
```

#### Confidence

| API                        | Description                              | Confidence |
|----------------------------|------------------------------------------|------------|
| Libraray.cs                | Hand-written library management code     |     90%    |
| Structs.cs                 | Declarations of all struct data types    |     90%    |
| Enums.cs                   | Declarations os all enum data types      |     90%    |
| API.Initialize             | C# Implementation of A3D_INITIALIZE_DATA |     95%    |
| API.A3D*Get                | Get functions for structs                |     99%    |
| API.A3D*Create             | Create functions for structs             |     99%    |
| API.A3D*Edit               | Edit functions for structs               |     99%    |
| API.A3DAsmModelFileLoad*   | Loading functions                        |     90%    |
| API.A3DAsmModelFileExport* | Export functions                         |     90%    |
| API.cs (other)             | Other Exchange functions                 |     60%    |



## Prerequisites
In order to build and use ExchangeSharp, the following software components are required:
* [HOOPS Exchange 2020 SP2](https://developer.techsoft3d.com/hoops/exchange/downloads/latest/) (or binary compatible version)
* [.NET Core](https://dotnet.microsoft.com/download/dotnet-core)

## Building ExchangeSharp.dll
1. Be sure you have Exchange installed and licensed correctly. 
 	1. Unpack the archive.
 	1. Place hoops_license.h _and_ hoops_license.cs in the `include` folder.
	1. Building and running the sample applications contained within.
1. Clone the ExchangeSharp repository.
1. Build ExchangeSharp
	1. Change to the `ExchangeSharp` folder.
	1. Run the command `dotnet build`.
	1. `ExchangeSharp.dll` can be found in the `bin/Debug/netcoreapp3.1` folder.

## Building and Running the Examples
1. Change to `examples/DriverApp`
1. Copy `hoops_license.cs` to this folder.
1. `dotnet build`
1. `dotnet run --exchange "/path/to/exchange/bin/win64" "/path/to/exchange/samples/data/prc/helloworld.prc"`

# What is `Classes.cs`?
Similar to the [ExchangeToolkit](https://labs.techsoft3d.com/project/exchange-toolkit/), ExchangeSharp includes classes with the postfix "Wrapper". These classes call `API.Initialize` and `Get` in the constructor, and they free upon destruction. Using these classes results in code that looks like this:

```csharp
A3DAsmModelFileWrapper d( model_file );
// Use object here
```

Structs that do not have corresponding `Get` function (`A3DVector3dData` for example) are wrapped as well. Code provided in the `examples` folder make use of these wrapper classes in order to make the implementation more concise.



